When we want to read a file
First we have to open it
And then once the file is opened, you could either read from that file or you could write to that file
or append to it, or get the status of that file.
By status I mean that file data.
For example, you want to see when that file was last modified.

Now what really happens when you open a file is that you are you're not actually moving the whole contents
of that file to your memory.
What happens is that you are just saving a number regarding that file.
It's called a file descriptor.

file descriptor - is just a number that has been assigned to an opened file
                  each open file has a unique file descriptor

<FileHandle> objects are <EventEmitter>s
This means FileHandle object is inheriting from EventEmitter object

**********************************************************************************************************************************

Node.js File Reading: readFileSync vs open

1. fs.readFileSync / fs.readFile

    High-level API (convenience method).

    You don’t explicitly call open.
    Internally Node.js does:
        open file
        read contents
        close file

Simpler to use, best for small/medium files.

Example:

const fs = require("fs");
const content = fs.readFileSync("./text.txt");
console.log(content.toString("utf-8"));

2. fs.open

Low-level API.
Returns a file descriptor (callback version) or FileHandle (promise version).
Requires manual lifecycle management:
open → read/write → close.
Useful for:
    Reading part of a file
    Handling large files efficiently
    Keeping a file open for multiple operations

Example:

const fs = require("fs/promises");

(async () => {
  const fileHandle = await fs.open("./text.txt", "r");
  const buffer = Buffer.alloc(1024);
  await fileHandle.read(buffer, 0, buffer.length, 0);
  console.log(buffer.toString("utf-8"));
  await fileHandle.close();
})();

✅ Key Takeaway

readFileSync / readFile: Node handles open → read → close automatically.

open: You must manage the file lifecycle yourself (more control, more work).


****************************************************************************************************************

When you call:

await commandFileHandler.read(buff, offset, length, position);


commandFileHandler → the file on disk (your source).

buff → the buffer in memory (your destination).

Now for those parameters:

1. offset
    Where in the buffer to start writing the file’s data.
    Example: offset = 0 → write at the beginning of the buffer.

    Example: offset = 10 → skip the first 10 bytes of the buffer, start filling after that.

2. length
     How many bytes to read from the file and copy into the buffer.
     Example: length = 20 → read 20 bytes from the file.


3. position

    Where in the file (commandFileHandler) to start reading.

    Example: position = 0 → read from the beginning of the file.
    Example: position = 50 → skip the first 50 bytes in the file, then start reading.

Putting it together:

Take length bytes from the file (commandFileHandler), starting at position in the file, and put them into the buffer (buff), starting at offset inside the buffer.